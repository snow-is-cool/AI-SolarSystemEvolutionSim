<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10.0, user-scalable=yes">
    <title>2D Solar System Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top on small screens */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text color */
            overflow: hidden; /* Prevent scrolling on the body by default */
            user-select: none; /* Prevent text selection */
            -webkit-overflow-scrolling: touch; /* Enable smooth scrolling on iOS */
            padding: 0.5rem; /* Reduce padding */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .canvas-container { /* New container for canvas and stats */
            position: relative; /* Make this the positioning context for absolute children */
            width: 100%;
            height: 300px; /* Slightly reduce canvas container height */
            margin-bottom: 1rem; /* Reduce margin */
            border-radius: 0.5rem; /* Reduce border radius */
            box-shadow: 0 8px 12px -3px rgba(0, 0, 0, 0.1), 0 3px 5px -2px rgba(0, 0, 0, 0.05); /* Slightly smaller shadow */
            background-color: #00001a; /* Apply background to container */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Fill the container */
            height: 100%; /* Fill the container */
            cursor: grab; /* Indicate draggable */
            /* Removed background-color, border-radius, box-shadow from canvas */
        }
        canvas:active {
            cursor: grabbing; /* Indicate dragging */
        }
        .controls-container { /* Main container for all controls */
            display: flex;
            flex-direction: column; /* Stack main groups vertically */
            align-items: center;
            gap: 0.75rem; /* Gap between main groups */
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
            box-sizing: border-box;
            width: 100%;
        }
        .action-buttons-group { /* New group for buttons above settings */
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            justify-content: center;
            gap: 0.5rem; /* Gap between buttons */
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            width: 100%; /* Take full width */
        }
        .control-group { /* Generic group for inputs/displays (like zoom) */
            display: flex;
            align-items: center;
            gap: 0.3rem; /* Reduce gap */
            background-color: rgba(0, 0, 0, 0.4); /* Default for zoom/teleport groups */
            padding: 0.3rem 0.6rem; /* Reduce padding */
            border-radius: 0.3rem; /* Reduce border radius */
        }
        .modifier-group { /* Simulation settings box */
            display: flex;
            flex-direction: column; /* Stack items vertically */
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.3rem; /* Further reduced gap within this group */
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.3rem 0.5rem; /* Further reduced padding */
            border-radius: 0.5rem; /* Slightly larger border radius */
            transition: all 0.3s ease-in-out; /* Smooth transition for showing/hiding */
            max-height: 500px; /* Max height for transition */
            overflow: hidden; /* Hide overflow during transition */
            opacity: 1;
            transform: translateY(0);
            width: 100%; /* Take full width */
        }
        .modifier-group.hidden {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none; /* Disable interactions when hidden */
        }
        .modifier-group .control-group { /* Adjust control groups inside modifier group */
            background-color: transparent; /* No background for inner groups */
            padding: 0.1rem 0; /* Smaller padding */
            justify-content: space-between; /* Distribute label and input */
            width: 100%; /* Take full width within modifier group */
        }
        .modifier-group .control-group label {
            flex-shrink: 0; /* Prevent label from shrinking */
            margin-right: 0.5rem; /* Space between label and input */
        }
        .modifier-group .control-group input {
            flex-grow: 1; /* Allow input to grow */
            max-width: 80px; /* Limit input width */
        }
        .modifier-group-title {
            font-weight: bold;
            color: #90cdf4; /* Light blue for title */
            margin-bottom: 0.5rem;
            text-align: center;
            width: 100%;
        }
        button {
            padding: 0.3rem 0.6rem; /* Even smaller button padding */
            border-radius: 0.3rem; /* Reduce border radius */
            font-weight: 500; /* Slightly thinner font-weight */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.1), 0 1px 3px -1px rgba(0, 0, 0, 0.06); /* Smaller shadow */
            font-size: 0.65rem; /* Even smaller font size */
            flex-shrink: 0; /* Prevent buttons from stretching */
            flex-grow: 0; /* Prevent buttons from growing */
        }
        button:hover {
            transform: translateY(-1px); /* Reduce hover lift */
            box-shadow: 0 4px 8px -1px rgba(0, 0, 0, 0.15), 0 2px 4px -1px rgba(0, 0, 0, 0.08); /* Smaller hover shadow */
        }
        .btn-primary {
            background-color: #63b3ed; /* Blue */
            color: #1a202c;
        }
        .btn-primary:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        .btn-secondary { /* For small +/- buttons */
            padding: 0.1rem 0.3rem; /* Even smaller for secondary buttons */
            font-size: 0.6rem; /* Even smaller font size */
            border-radius: 0.2rem; /* Reduce border radius */
            background-color: #a0aec0;
            color: #1a202c;
        }
        .btn-secondary:hover {
            background-color: #718096;
        }
        .global-stats-bar { /* Style for the integrated global stats bar */
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.3rem 0.6rem; /* Reduce padding */
            border-radius: 0.3rem; /* Reduce border radius */
            font-size: 0.7rem; /* Reduce font size */
            color: #cbd5e0;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 0.5rem; /* Reduce margin */
            display: flex; /* Use flexbox for alignment */
            justify-content: space-around; /* Distribute items evenly */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 0.3rem; /* Reduce gap */
        }
        .global-stats-bar span {
            white-space: nowrap; /* Prevent text from wrapping within a stat item */
        }
        .stats-display { /* Specific style for the dynamic stats panel on canvas */
            position: absolute;
            top: 0.5rem; /* Reduce top margin */
            right: 0.5rem; /* Reduce right margin */
            padding: 0.3rem 0.6rem; /* Reduce padding */
            border-radius: 0.3rem; /* Reduce border radius */
            background-color: rgba(0, 0, 0, 0.6); /* Slightly more opaque for visibility */
            font-size: 0.65rem; /* Reduce font size */
            text-align: right; /* Align text within the stats box */
            color: #e2e8f0;
            z-index: 10; /* Ensure it's above the canvas elements */
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .stats-display.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction when hidden */
        }
        .main-content-wrapper {
            width: 100%;
            max-width: 4xl; /* Same as the max-w-4xl on the div */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem; /* Reduce padding */
            box-sizing: border-box;
            position: relative; /* Added for positioning the home button inside */
        }
        .particle-input {
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #4a5568;
            border-radius: 0.2rem; /* Reduce border radius */
            padding: 0.15rem 0.3rem; /* Further reduced padding */
            color: #e2e8f0;
            width: 60px; /* Reduce width */
            text-align: center;
            font-size: 0.65rem; /* Reduce font size */
        }
        .particle-input:focus {
            outline: none;
            border-color: #63b3ed;
            box-shadow: 0 0 0 1px rgba(99, 179, 237, 0.5); /* Smaller shadow */
        }
        .home-button {
            position: absolute;
            top: 0.5rem; /* Position relative to .main-content-wrapper's padding */
            left: 0.5rem; /* Position relative to .main-content-wrapper's padding */
            z-index: 20; /* Ensure it's on top */
            border-radius: 0.5rem; /* Rounded square */
            overflow: hidden; /* Ensures image respects border-radius */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .home-button img {
            display: block;
            width: 32px; /* Small size for the icon */
            height: 32px;
            background-color: rgba(255, 255, 255, 0.1); /* Slight background for visibility */
            padding: 4px;
            border-radius: 0.5rem; /* Rounded square */
            transition: background-color 0.2s ease;
        }
        .home-button:hover img {
            background-color: rgba(255, 255, 255, 0.2);
        }


        /* Mobile-specific adjustments (further reduced sizes) */
        @media (max-width: 600px) {
            body {
                justify-content: flex-start; /* Align content to top on small screens */
                padding: 0.25rem; /* Further reduce padding */
            }
            .main-content-wrapper {
                margin-top: 0.25rem;
                margin-bottom: 0.25rem;
                padding: 0.25rem; /* Further reduce padding */
            }
            .controls-container {
                flex-direction: column; /* Stack controls vertically */
                align-items: center;
                gap: 0.5rem; /* Further reduce gap */
            }
            .action-buttons-group {
                gap: 0.3rem; /* Even smaller gap for action buttons */
                padding: 0.4rem 0.25rem;
            }
            .control-group {
                width: 100%; /* Make zoom controls full width */
                justify-content: space-around; /* Distribute items evenly */
                padding: 0.4rem 0.25rem; /* Further reduce padding */
            }
            .modifier-group {
                width: 100%;
                padding: 0.2rem 0.2rem; /* Even smaller padding for modifier group */
                gap: 0.2rem; /* Even smaller gap */
            }
            .modifier-group .control-group {
                padding: 0.05rem 0; /* Even smaller padding for inner control groups */
            }
            button {
                width: auto; /* Allow buttons to size naturally */
                padding: 0.2rem 0.4rem; /* Even smaller padding */
                font-size: 0.55rem; /* Even smaller font size */
            }
            .btn-secondary {
                padding: 0.05rem 0.15rem; /* Even smaller for secondary buttons */
                font-size: 0.5rem;
            }
            .global-stats-bar {
                font-size: 0.6rem; /* Further reduce font size */
                padding: 0.15rem 0.3rem; /* Further reduce padding */
                gap: 0.2rem; /* Further reduce gap */
            }
            .stats-display {
                top: 0.25rem; /* Further reduce top margin */
                right: 0.25rem; /* Further reduce right margin */
                font-size: 0.55rem; /* Further reduce font size */
                padding: 0.15rem 0.3rem; /* Further reduce padding */
            }
            h1 {
                font-size: 1.5rem; /* Further reduce heading size */
                margin-bottom: 0rem; /* Further reduce margin */
            }
            p {
                font-size: 0.6rem; /* Further reduce paragraph size */
            }
            .canvas-container {
                height: 250px; /* Further reduce canvas container height */
                margin-bottom: 0rem; /* Further reduce margin */
            }
            .particle-input {
                font-size: 0.5rem; /* Even smaller font size */
                padding: 0.1rem 0.2rem; /* Even smaller padding */
                width: 45px; /* Even smaller width */
            }
            .home-button {
                top: 0.25rem;
                left: 0.25rem;
            }
            .home-button img {
                width: 28px;
                height: 28px;
                padding: 3px;
            }
        }
    </style>
</head>
<body>
    <div class="main-content-wrapper p-6 bg-gray-800 rounded-xl shadow-lg mx-auto my-8">
        <a href="https://snow-is-cool.github.io" id="homeButton" class="home-button">
            <img src="tohome.png" alt="Home">
        </a>
        <h1 class="text-3xl font-bold mb-2 text-blue-300">2D Solar System Evolution</h1>
        <p class="mt-1 text-sm text-gray-400 text-center">
            Watch as small particles orbit a central star and collide, simulating gravitational interactions.
        <br><br></p>
        <div class="canvas-container">
            <canvas id="solarSystemCanvas"></canvas>
            <div id="statsDisplay" class="stats-display hidden"></div>
        </div>

        <div class="controls-container">
            <div class="action-buttons-group"> <div class="control-group">
                    <span class="text-sm">Zoom:</span>
                    <button id="zoomOutFastBtn" class="btn-secondary">--</button>
                    <button id="zoomOutBtn" class="btn-secondary">-</button>
                    <span id="zoomLevelDisplay" class="text-sm font-bold w-12 text-center">1.0x</span>
                    <button id="zoomInBtn" class="btn-secondary">+</button>
                    <button id="zoomInFastBtn" class="btn-secondary">++</button>
                </div>

                <button id="resetSimBtn" class="btn-primary">Reset Simulation</button>
                <button id="resetViewBtn" class="btn-primary">Reset View</button>
                <button id="pausePlayBtn" class="btn-primary">Pause</button>
                <button id="toggleTrackingBtn" class="btn-primary">Toggle Tracking</button>
                <div class="control-group">
                    <span class="text-sm">Teleport to random:</span>
                    <button id="teleportParticleBtn" class="btn-secondary">(P)</button>
                    <button id="teleportClusterBtn" class="btn-secondary">(C)</button>
                    <button id="teleportRandomObjectBtn" class="btn-secondary">(R)</button>
                </div>
                <button id="toggleScrollLockBtn" class="btn-primary">Lock Scroll</button>
                <button id="toggleSettingsBtn" class="btn-primary">Hide Settings</button>
                <button id="toggleRocheLimitBtn" class="btn-primary">Show Roche Limit</button> </div>

            <div id="globalStatsBar" class="global-stats-bar">
                <span>Simulation Time: <span id="simTimeDisplay">0</span> frames</span>
                <span>Total Particles: <span id="totalParticlesDisplay">0</span></span>
                <span>Total Clusters: <span id="totalClustersDisplay">0</span></span>
            </div>

            <div id="modifierGroup" class="modifier-group">
                <div class="modifier-group-title">Simulation Settings</div>
                <div class="control-group">
                    <label for="particleCountInput" class="text-sm">Particles:</label>
                    <input type="number" id="particleCountInput" class="particle-input" value="1000" min="100" max="10000">
                </div>
                <div class="control-group">
                    <label for="minParticleSizeInput" class="text-sm">Min Radius:</label>
                    <input type="number" id="minParticleSizeInput" class="particle-input" value="1" min="0.1" step="0.1">
                </div>
                <div class="control-group">
                    <label for="maxParticleSizeInput" class="text-sm">Max Radius:</label>
                    <input type="number" id="maxParticleSizeInput" class="particle-input" value="2.5" min="0.2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="minSpawnDistanceInput" class="text-sm">Min Spawn Distance:</label>
                    <input type="number" id="minSpawnDistanceInput" class="particle-input" value="250" min="0" step="10">
                </div>
                <div class="control-group">
                    <label for="maxSpawnDistanceInput" class="text-sm">Max Spawn Distance:</label>
                    <input type="number" id="maxSpawnDistanceInput" class="particle-input" value="600" min="10" step="10">
                </div>
                <div class="control-group">
                    <label for="starMassInput" class="text-sm">Star Mass:</label>
                    <input type="number" id="starMassInput" class="particle-input" value="5000" min="100" step="100">
                </div>
                <div class="control-group">
                    <label for="gravityConstantInput" class="text-sm">Gravity (G):</label>
                    <input type="number" id="gravityConstantInput" class="particle-input" value="0.01" min="0.001" step="0.001">
                </div>
                <div class="control-group">
                    <label for="cohesionConstantInput" class="text-sm">Cohesion (C):</label>
                    <input type="number" id="cohesionConstantInput" class="particle-input" value="50.0" min="0" step="0.1">
                </div>
                <div class="control-group">
                    <label for="velocityDampeningInput" class="text-sm">Velocity Dampening:</label>
                    <input type="number" id="velocityDampeningInput" class="particle-input" value="0.9" min="0" max="1" step="0.01">
                </div>
                <button id="resetDefaultsBtn" class="btn-primary mt-2">Reset to Defaults</button> </div>
        </div>

    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('solarSystemCanvas');
        const ctx = canvas.getContext('2d');
        const resetSimBtn = document.getElementById('resetSimBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const simTimeDisplay = document.getElementById('simTimeDisplay');
        const totalParticlesDisplay = document.getElementById('totalParticlesDisplay');
        const totalClustersDisplay = document.getElementById('totalClustersDisplay');
        const pausePlayBtn = document.getElementById('pausePlayBtn');
        const toggleTrackingBtn = document.getElementById('toggleTrackingBtn');
        const statsDisplay = document.getElementById('statsDisplay');
        const particleCountInput = document.getElementById('particleCountInput');
        const homeButton = document.getElementById('homeButton'); // Get the home button

        // Input elements for adjustable constants
        const minParticleSizeInput = document.getElementById('minParticleSizeInput');
        const maxParticleSizeInput = document.getElementById('maxParticleSizeInput');
        const minSpawnDistanceInput = document.getElementById('minSpawnDistanceInput');
        const maxSpawnDistanceInput = document.getElementById('maxSpawnDistanceInput');
        const starMassInput = document.getElementById('starMassInput');
        const gravityConstantInput = document.getElementById('gravityConstantInput');
        const cohesionConstantInput = document.getElementById('cohesionConstantInput');
        const velocityDampeningInput = document.getElementById('velocityDampeningInput');

        // Teleport buttons
        const teleportParticleBtn = document.getElementById('teleportParticleBtn');
        const teleportClusterBtn = document.getElementById('teleportClusterBtn');
        const teleportRandomObjectBtn = document.getElementById('teleportRandomObjectBtn');

        // Zoom control buttons
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomInFastBtn = document.getElementById('zoomInFastBtn');
        const zoomOutFastBtn = document.getElementById('zoomOutFastBtn');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');

        // Other UI elements
        const toggleSettingsBtn = document.getElementById('toggleSettingsBtn');
        const modifierGroup = document.getElementById('modifierGroup');
        const toggleScrollLockBtn = document.getElementById('toggleScrollLockBtn');
        const resetDefaultsBtn = document.getElementById('resetDefaultsBtn');
        const toggleRocheLimitBtn = document.getElementById('toggleRocheLimitBtn');

        // --- Sound Variables ---
        let crashloudAudio = null;
        let crashquietAudio = null;

        // Collision sound thresholds (Impact speed)
        const LOUD_IMPACT_THRESHOLD = 3.0; // Speed above which crashloud.mp3 plays for Cluster vs Cluster
        const QUIET_IMPACT_THRESHOLD = 0.25; // Speed below which no sound plays for Cluster vs Cluster

        const MAX_AUDIO_VOLUME = 0.8; // Max global volume for sounds
        const PVP_PVC_MAX_VOLUME = 0.5; // Max volume for Particle vs Particle/Cluster sounds
        const CVC_LOUD_VOLUME = 0.5; // Fixed volume for loud Cluster vs Cluster crashes

        const MAX_AUDIBLE_DISTANCE = 1500; // Distance beyond which sounds fade out completely
        const MIN_VOLUME_AT_MAX_DISTANCE_FACTOR = 0.05; // At MAX_AUDIBLE_DISTANCE, volume will be 5% of baseVolume

        // --- Simulation Constants (now 'let' to be adjustable) ---
        // Store initial default values separately for the reset button
        const DEFAULT_G = 0.01;
        const DEFAULT_COHESION_FORCE_G = 50.0;
        const DEFAULT_PARTICLE_COUNT = 1000;
        const DEFAULT_STAR_RADIUS = 25;
        let DEFAULT_STAR_MASS = 5000;
        const DEFAULT_MIN_PARTICLE_RADIUS = 1;
        const DEFAULT_MAX_PARTICLE_RADIUS = 2.5;
        const DEFAULT_INITIAL_DISK_INNER_RADIUS = 250;
        const DEFAULT_INITIAL_DISK_OUTER_RADIUS = 600;
        const DEFAULT_COLLISION_DAMPENING = 0.9; // Represents fraction of velocity LOST

        let G = DEFAULT_G;
        let COHESION_FORCE_G = DEFAULT_COHESION_FORCE_G;
        let PARTICLE_COUNT = DEFAULT_PARTICLE_COUNT;
        const STAR_RADIUS = DEFAULT_STAR_RADIUS;
        let STAR_MASS = DEFAULT_STAR_MASS;
        let MIN_PARTICLE_RADIUS = DEFAULT_MIN_PARTICLE_RADIUS;
        let MAX_PARTICLE_RADIUS = DEFAULT_MAX_PARTICLE_RADIUS;
        let INITIAL_DISK_INNER_RADIUS = DEFAULT_INITIAL_DISK_INNER_RADIUS;
        let INITIAL_DISK_OUTER_RADIUS = DEFAULT_INITIAL_DISK_OUTER_RADIUS;

        const PARTICLE_DENSITY = 0.5; // Density of individual small particles
        const INITIAL_VELOCITY_FACTOR = 1;
        const VELOCITY_NOISE = 0.001;
        const CAMERA_MOVE_SPEED = 5;
        const CLUSTER_TOUCH_EPSILON = 0.1;

        // Collision dampening is now controlled by input, breakup code is removed
        let COLLISION_DAMPENING = DEFAULT_COLLISION_DAMPENING;


        // --- Simulation Variables ---
        let particles = [];
        let simulationTime = 0;
        const simulationSpeed = 1.0;
        let zoomLevel = 1.0;
        let cameraWorldX = 0;
        let cameraWorldY = 0;
        const keys = {};

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isPaused = false;

        let isTracking = false;
        let trackedParticle = null;
        let trackingOffsetX = 0;
        let trackingOffsetY = 0;

        let clusterNameMap = new Map();
        let nextClusterId = 1;

        let showRocheLimit = false; // Changed to false by default

        // Initialize scroll lock state to unlocked
        let isScrollLocked = false;


        // --- Helper Functions ---

        // Calculates the distance between two particles' centers
        function distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculates the squared distance between two particles' centers
        function distanceSq(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return dx * dx + dy * dy;
        }

        /**
         * Finds all particles that are part of the same "cluster" as the startParticle.
         * A cluster is defined by particles touching or being within a small epsilon distance.
         * Uses a Breadth-First Search (BFS) approach.
         * @param {Particle} startParticle The particle to start the cluster search from.
         * @returns {Array<Particle>} An array of particles belonging to the same cluster.
         */
        function findCluster(startParticle) {
            if (!startParticle || !startParticle.isAlive) return [];

            const cluster = new Set();
            const queue = [startParticle];
            cluster.add(startParticle);

            while (queue.length > 0) {
                const currentP = queue.shift();

                for (const otherP of particles) {
                    // Ensure otherP is a valid object before accessing its properties
                    if (otherP && otherP.isAlive && otherP !== currentP && !otherP.isStar && !cluster.has(otherP)) {
                        const requiredDistance = currentP.radius + otherP.radius;
                        if (distance(currentP, otherP) <= requiredDistance + CLUSTER_TOUCH_EPSILON) {
                            cluster.add(otherP);
                            queue.push(otherP);
                        }
                    }
                }
            }
            return Array.from(cluster);
        }

        /**
         * Counts the total number of particles (excluding the sun) and identifies distinct clusters (groups of 2 or more non-star particles).
         * This function now also triggers cluster naming.
         * @returns {{totalParticles: number, clusters: Array<Array<Particle>>}} An object containing the counts and the list of clusters.
         */
        function countGlobalStats() {
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            const totalParticles = nonStarParticles.length;

            const visited = new Set();
            const allClusters = [];

            for (const startParticle of nonStarParticles) {
                if (!visited.has(startParticle)) {
                    const currentCluster = new Set();
                    const queue = [startParticle];
                    visited.add(startParticle);
                    currentCluster.add(startParticle);

                    while (queue.length > 0) {
                        const currentP = queue.shift();

                        for (const otherP of nonStarParticles) {
                            if (otherP !== currentP && !visited.has(otherP)) {
                                const requiredDistance = currentP.radius + otherP.radius;
                                if (distance(currentP, otherP) <= requiredDistance + CLUSTER_TOUCH_EPSILON) {
                                    visited.add(otherP);
                                    currentCluster.add(otherP);
                                    queue.push(otherP);
                                }
                            }
                        }
                    }
                    if (currentCluster.size > 1) { // Only consider groups of 2 or more particles as clusters
                        const clusterArray = Array.from(currentCluster);
                        getClusterName(clusterArray);
                        allClusters.push(clusterArray);
                    }
                }
            }
            return { totalParticles, totalClusters: allClusters.length, clusters: allClusters };
        }

        /**
         * Generates or retrieves a stable decimal name for a cluster or returns particle name for single particle.
         * @param {Array<Particle>} clusterParticles An array of particles forming the cluster.
         * @returns {string | null} The cluster name (e.g., "C1", "C2") or the particle name (e.g., "P1") or null if invalid.
         */
        function getClusterName(clusterParticles) {
            if (!clusterParticles || clusterParticles.length === 0) return null;
            if (clusterParticles.length === 1) {
                return clusterParticles[0].name; // Return the name of the single particle
            }

            const particleNames = clusterParticles.map(p => p.name).sort();
            const clusterKey = particleNames.join('-');

            if (clusterNameMap.has(clusterKey)) {
                return clusterNameMap.get(clusterKey);
            } else {
                const newClusterName = 'C' + nextClusterId;
                clusterNameMap.set(clusterKey, newClusterName);
                nextClusterId++;
                return newClusterName;
            }
        }


        // --- Particle Class Definition ---
        class Particle {
            constructor(x, y, vx, vy, radius, color, isStar = false, name = '') {
                this.x = x;
                this.y = y;
                this.vx = vx; // velocity x
                this.vy = vy; // velocity y
                this.radius = radius;
                this.mass = radius * radius * PARTICLE_DENSITY;
                this.color = color;
                this.isStar = isStar;
                this.isAlive = true; // Flag to manage particle state for removal/processing
                this.name = name;
            }

            // Update particle's position and lifetime
            update() {
                if (!this.isAlive) return;

                if (this.isStar) {
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                this.x += this.vx * simulationSpeed;
                this.y += this.vy * simulationSpeed;
            }

            // Draw the particle on the canvas
            draw() {
                if (!this.isAlive) return;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                if (this.radius > 5) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // --- Core Simulation Logic ---

        function resetCamera() {
            zoomLevel = 1.0;
            updateZoomLevelDisplay();
            isTracking = false;
            trackedParticle = null;
            trackingOffsetX = 0;
            trackingOffsetY = 0;
            cameraWorldX = 0;
            cameraWorldY = 0;
            toggleTrackingBtn.textContent = 'Toggle Tracking';
            statsDisplay.classList.add('hidden');
        }

        function resetView() {
            zoomLevel = 1.0;
            updateZoomLevelDisplay();
            cameraWorldX = 0;
            cameraWorldY = 0;
            isTracking = false;
            trackedParticle = null;
            trackingOffsetX = 0;
            trackingOffsetY = 0;
            toggleTrackingBtn.textContent = 'Toggle Tracking';
            statsDisplay.classList.add('hidden');
        }

        function initSimulation() {
            const desiredParticleCount = parseInt(particleCountInput.value, 10);
            if (isNaN(desiredParticleCount) || desiredParticleCount < 100 || desiredParticleCount > 10000) {
                alert('Please enter a number between 100 and 10,000 for particle count.');
                particleCountInput.value = DEFAULT_PARTICLE_COUNT;
                PARTICLE_COUNT = DEFAULT_PARTICLE_COUNT;
            } else {
                PARTICLE_COUNT = desiredParticleCount;
            }

            MIN_PARTICLE_RADIUS = parseFloat(minParticleSizeInput.value);
            MAX_PARTICLE_RADIUS = parseFloat(maxParticleSizeInput.value);
            INITIAL_DISK_INNER_RADIUS = parseFloat(minSpawnDistanceInput.value);
            INITIAL_DISK_OUTER_RADIUS = parseFloat(maxSpawnDistanceInput.value);
            STAR_MASS = parseFloat(starMassInput.value);
            G = parseFloat(gravityConstantInput.value);
            COHESION_FORCE_G = parseFloat(cohesionConstantInput.value);
            COLLISION_DAMPENING = parseFloat(velocityDampeningInput.value); // This value now represents fraction of velocity LOST

            if (isNaN(MIN_PARTICLE_RADIUS) || MIN_PARTICLE_RADIUS <= 0) {
                alert('Min Radius must be a positive number.');
                minParticleSizeInput.value = DEFAULT_MIN_PARTICLE_RADIUS;
                MIN_PARTICLE_RADIUS = DEFAULT_MIN_PARTICLE_RADIUS;
            }
            if (isNaN(MAX_PARTICLE_RADIUS) || MAX_PARTICLE_RADIUS <= MIN_PARTICLE_RADIUS) {
                alert('Max Radius must be a number greater than Min Radius.');
                maxParticleSizeInput.value = DEFAULT_MAX_PARTICLE_RADIUS;
                MAX_PARTICLE_RADIUS = DEFAULT_MAX_PARTICLE_RADIUS;
            }
            if (isNaN(INITIAL_DISK_INNER_RADIUS) || INITIAL_DISK_INNER_RADIUS < 0) {
                alert('Min Spawn Distance must be a non-negative number.');
                minSpawnDistanceInput.value = DEFAULT_INITIAL_DISK_INNER_RADIUS;
                INITIAL_DISK_INNER_RADIUS = DEFAULT_INITIAL_DISK_INNER_RADIUS;
            }
            if (isNaN(INITIAL_DISK_OUTER_RADIUS) || INITIAL_DISK_OUTER_RADIUS <= INITIAL_DISK_INNER_RADIUS) {
                alert('Max Spawn Distance must be a number greater than Min Spawn Distance.');
                maxSpawnDistanceInput.value = DEFAULT_INITIAL_DISK_OUTER_RADIUS;
                INITIAL_DISK_OUTER_RADIUS = DEFAULT_INITIAL_DISK_OUTER_RADIUS;
            }
            if (isNaN(STAR_MASS) || STAR_MASS <= 0) {
                alert('Star Mass must be a positive number.');
                starMassInput.value = DEFAULT_STAR_MASS;
                STAR_MASS = DEFAULT_MASS;
            }
            if (isNaN(G)) {
                alert('Gravity Constant (G) must be a number.');
                gravityConstantInput.value = DEFAULT_G;
                G = DEFAULT_G;
            }
            if (isNaN(COHESION_FORCE_G)) {
                alert('Cohesion Constant (C) must be a number.');
                cohesionConstantInput.value = DEFAULT_COHESION_FORCE_G;
                COHESION_FORCE_G = DEFAULT_COHESION_FORCE_G;
            }
            if (isNaN(COLLISION_DAMPENING) || COLLISION_DAMPENING < 0 || COLLISION_DAMPENING > 1) {
                alert('Velocity Dampening must be a number between 0 and 1.');
                velocityDampeningInput.value = DEFAULT_COLLISION_DAMPENING;
                COLLISION_DAMPENING = DEFAULT_COLLISION_DAMPENING;
            }


            particles = [];
            simulationTime = 0;
            simTimeDisplay.textContent = simulationTime;
            resetCamera();

            isPaused = false;
            pausePlayBtn.textContent = 'Pause';

            clusterNameMap = new Map();
            nextClusterId = 1;

            const star = new Particle(
                0, 0,
                0, 0,
                STAR_RADIUS,
                '#FFFF00',
                true,
                "S1"
            );
            star.mass = STAR_MASS;
            particles.push(star);

            const redGreyPalette = ['#FF0000', '#808080'];
            const orangeBluePalette = ['#FFA500', '#0000FF'];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const dist = INITIAL_DISK_INNER_RADIUS + Math.random() * (INITIAL_DISK_OUTER_RADIUS - INITIAL_DISK_INNER_RADIUS);
                const angle = Math.random() * Math.PI * 2;

                const x = Math.cos(angle) * dist;
                const y = Math.sin(angle) * dist;

                const r_to_star = distance(star, {x: x, y: y});
                const orbitalSpeed = Math.sqrt(G * star.mass / r_to_star) * INITIAL_VELOCITY_FACTOR;

                const dx = x - star.x;
                const dy = y - star.y;
                const magnitude = Math.sqrt(dx*dx + dy*dy);
                const vx_orbital = (-dy / magnitude) * orbitalSpeed;
                const vy_orbital = (dx / magnitude) * orbitalSpeed;

                const vx_noise = (Math.random() - 0.5) * VELOCITY_NOISE;
                const vy_noise = (Math.random() - 0.5) * VELOCITY_NOISE;

                const radius = Math.random() * (MAX_PARTICLE_RADIUS - MIN_PARTICLE_RADIUS) + MIN_PARTICLE_RADIUS;

                let color;
                let normalizedDistance = (r_to_star - INITIAL_DISK_INNER_RADIUS) / (INITIAL_DISK_OUTER_RADIUS - INITIAL_DISK_INNER_RADIUS);
                normalizedDistance = Math.max(0, Math.min(1, normalizedDistance));

                const orangeBlueProbability = normalizedDistance;
                const redGreyProbability = 1 - normalizedDistance;

                if (Math.random() < orangeBlueProbability) {
                    color = orangeBluePalette[Math.floor(Math.random() * orangeBluePalette.length)];
                } else {
                    color = redGreyPalette[Math.floor(Math.random() * redGreyPalette.length)];
                }

                const particleName = 'P' + (i + 1);
                particles.push(new Particle(x, y, vx_orbital + vx_noise, vy_orbital + vy_noise, radius, color, false, particleName));
            }
        }

        function applyGravity() {
            const activeParticles = particles.filter(p => p.isAlive);

            for (let i = 0; i < activeParticles.length; i++) {
                for (let j = i + 1; j < activeParticles.length; j++) {
                    const p1 = activeParticles[i];
                    const p2 = activeParticles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const r_sq = dx * dx + dy * dy;
                    const r = Math.sqrt(r_sq);

                    if (r < 1) { // Prevent division by zero or excessive force at zero distance
                        continue;
                    }

                    let totalForceMagnitude = 0;

                    const gravityForceMagnitude = G * p1.mass * p2.mass / r_sq;
                    totalForceMagnitude += gravityForceMagnitude;

                    if (!p1.isStar && !p2.isStar) {
                        const cohesionForceMagnitude = COHESION_FORCE_G * p1.mass * p2.mass / (r_sq * r_sq * r_sq * r_sq);
                        totalForceMagnitude += cohesionForceMagnitude;
                    }

                    const angle = Math.atan2(dy, dx);
                    const fx = Math.cos(angle) * totalForceMagnitude;
                    const fy = Math.sin(angle) * totalForceMagnitude;

                    if (!p1.isStar) {
                        p1.vx += (fx / p1.mass) * simulationSpeed;
                        p1.vy += (fy / p1.mass) * simulationSpeed;
                    }
                    if (!p2.isStar) {
                        p2.vx -= (fx / p2.mass) * simulationSpeed;
                        p2.vy -= (fy / p2.mass) * simulationSpeed;
                    }
                }
            }
        }

        // Helper function to play sound with distance attenuation
        function playCollisionSound(audioElement, baseVolume, impactX, impactY) {
            if (audioElement) {
                const distance = Math.sqrt(
                    Math.pow(impactX - cameraWorldX, 2) +
                    Math.pow(impactY - cameraWorldY, 2)
                );

                // Calculate distance attenuation factor with a minimum volume
                let distanceFactor = 1 - (distance / MAX_AUDIBLE_DISTANCE); // Goes from 1 (at 0 distance) to 0 (at MAX_AUDIBLE_DISTANCE)
                distanceFactor = Math.max(0, distanceFactor); // Clamp at 0, ensures no negative volume

                // Interpolate between MIN_VOLUME_AT_MAX_DISTANCE_FACTOR and 1 based on distanceFactor
                // This ensures volume doesn't drop completely to zero at MAX_AUDIBLE_DISTANCE
                let attenuatedFactor = MIN_VOLUME_AT_MAX_DISTANCE_FACTOR + (1 - MIN_VOLUME_AT_MAX_DISTANCE_FACTOR) * distanceFactor;

                let attenuatedVolume = baseVolume * attenuatedFactor;

                const clonedAudio = audioElement.cloneNode();
                clonedAudio.volume = Math.max(0, Math.min(MAX_AUDIO_VOLUME, attenuatedVolume)); // Clamp final volume
                clonedAudio.play().catch(e => { /* console.error("Audio playback error:", e); */ }); // Catch and ignore play errors
            }
        }

        function handleCollisions() {
            const activeParticles = particles.filter(p => p.isAlive);

            for (let i = 0; i < activeParticles.length; i++) {
                const p1 = activeParticles[i];
                if (!p1.isAlive) continue;

                for (let j = i + 1; j < activeParticles.length; j++) {
                    const p2 = particles[j];
                    if (!p2.isAlive) continue;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist_between_centers = distance(p1, p2);

                    if (dist_between_centers < (p1.radius + p2.radius)) {
                        // Collision point for sound
                        const impactX = (p1.x + p2.x) / 2;
                        const impactY = (p1.y + p2.y) / 2;

                        // --- Star Absorption ---
                        if (p1.isStar || p2.isStar) {
                            const absorber = p1.isStar ? p1 : p2;
                            const absorbed = p1.isStar ? p2 : p1;

                            if (!absorbed.isStar) {
                                absorber.mass += absorbed.mass;
                                absorbed.isAlive = false;
                            }
                            continue; // Skip rest of collision logic for star absorption
                        }

                        // --- Particle-Particle Collision (Dampened Bounce/Clumping ONLY) ---
                        const relVx = p2.vx - p1.vx;
                        const relVy = p2.vy - p1.vy;

                        const normalX = dx / dist_between_centers;
                        const normalY = dy / dist_between_centers;

                        const impactVelocityAlongNormal = relVx * normalX + relVy * normalY;

                        const overlap = (p1.radius + p2.radius) - dist_between_centers;
                        const separationFactor = overlap / dist_between_centers;
                        p1.x -= normalX * separationFactor * 0.5;
                        p1.y -= normalY * separationFactor * 0.5;
                        p2.x += normalX * separationFactor * 0.5;
                        p2.y += normalY * separationFactor * 0.5;

                        // Calculate impulse for inelastic collision (dampened bounce)
                        // COLLISION_DAMPENING now represents the fraction of velocity LOST (0 to 1)
                        // So, the coefficient of restitution (e) is 1 - COLLISION_DAMPENING
                        const coefficientOfRestitution = 1 - COLLISION_DAMPENING;
                        const impulse = (-(1 + coefficientOfRestitution) * impactVelocityAlongNormal) / (1 / p1.mass + 1 / p2.mass);

                        // Apply impulse
                        p1.vx -= (impulse / p1.mass) * normalX;
                        p1.vy -= (impulse / p1.mass) * normalY;
                        p2.vx += (impulse / p2.mass) * normalX;
                        p2.vy += (impulse / p2.mass) * normalY;

                        // --- Sound Logic ---
                        // Check if they are already part of the same cluster before collision (to prevent internal cluster sounds)
                        const p1Cluster = findCluster(p1);
                        const p2Cluster = findCluster(p2);
                        const areSameCluster = p1Cluster.some(p => p === p2);

                        if (!areSameCluster) {
                            const absImpactSpeed = Math.abs(impactVelocityAlongNormal);

                            const isP1TrulyCluster = p1Cluster.length > 1;
                            const isP2TrulyCluster = p2Cluster.length > 1;

                            if (isP1TrulyCluster && isP2TrulyCluster) {
                                // Cluster vs Cluster
                                if (absImpactSpeed >= LOUD_IMPACT_THRESHOLD) {
                                    playCollisionSound(crashloudAudio, CVC_LOUD_VOLUME, impactX, impactY);
                                } else if (absImpactSpeed > QUIET_IMPACT_THRESHOLD) {
                                    // Scale volume between 0 and 0.5 for CvC quiet crashes
                                    const volumeScaleFactor = (absImpactSpeed - QUIET_IMPACT_THRESHOLD) /
                                                              (LOUD_IMPACT_THRESHOLD - QUIET_IMPACT_THRESHOLD);
                                    playCollisionSound(crashquietAudio, volumeScaleFactor * PVP_PVC_MAX_VOLUME, impactX, impactY);
                                }
                            } else {
                                // Particle vs Particle or Particle vs Cluster
                                // Always play crashquiet, scaled, capping at 0.5
                                const volumeScaleFactor = Math.min(1.0, absImpactSpeed / QUIET_IMPACT_THRESHOLD);
                                playCollisionSound(crashquietAudio, volumeScaleFactor * PVP_PVC_MAX_VOLUME, impactX, impactY);
                            }
                        }
                    }
                }
            }
            particles = particles.filter(p => p.isAlive);
        }

        function updateZoomLevelDisplay() {
            zoomLevelDisplay.textContent = `${zoomLevel.toFixed(1)}x`;
        }

        // Helper for cross product for convex hull (determines turn direction)
        function crossProduct(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }

        // Monotone Chain algorithm for convex hull
        // Points are expected to be objects with {x, y} properties
        function convexHull(points) {
            if (points.length <= 2) {
                // For 0, 1, or 2 points, the hull is just the points themselves.
                // Sort to ensure consistent order for 2 points (e.g., for distance calculation).
                return points.sort((a, b) => a.x - b.x || a.y - b.y);
            }

            // Sort points lexicographically (by x, then by y)
            points.sort((a, b) => a.x - b.x || a.y - b.y);

            const lower = [];
            for (const p of points) {
                // While there are at least two points in the lower hull and adding the current point
                // would make a non-left turn (clockwise or collinear), pop the last point.
                while (lower.length >= 2 && crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }

            const upper = [];
            // Iterate in reverse for the upper hull
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                // While there are at least two points in the upper hull and adding the current point
                // would make a non-left turn (clockwise or collinear), pop the last point.
                while (upper.length >= 2 && crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }

            // Remove the last point of each hull, as it's a duplicate of the first point of the other hull.
            // This combines them correctly without redundant points.
            upper.pop();
            lower.pop();

            return lower.concat(upper);
        }

        /**
         * Calculates the circularity of a cluster based on its area (sum of individual circle areas)
         * and the perimeter of the convex hull of points sampled from the circles' circumferences.
         * Circularity = (4 * PI * Area) / (Perimeter^2)
         * A perfect circle has a circularity of 1.
         * @param {Array<Particle>} cluster The array of particles forming the cluster.
         * @returns {{circularity: number, totalArea: number, clusterPerimeter: number}} An object containing the circularity, area, and perimeter.
         */
        function calculateCircularity(cluster) {
            if (!cluster || cluster.length === 0) {
                return { circularity: 0, totalArea: 0, clusterPerimeter: 0 };
            }

            // Case 1: Single particle (or star)
            if (cluster.length === 1) {
                const p = cluster[0];
                const area = Math.PI * p.radius * p.radius;
                const perimeter = 2 * Math.PI * p.radius;
                return { circularity: 1.0, totalArea: area, clusterPerimeter: perimeter }; // A single particle is a perfect circle
            }

            // Calculate total area of the particles (treating as solid objects, ignoring overlap)
            let totalArea = 0;
            const outerPoints = []; // Collect points on the circumference for the convex hull

            // Number of points to sample per circle for the convex hull
            const pointsPerCircle = 16; // Increased resolution for better hull approximation

            for (const p of cluster) {
                totalArea += Math.PI * p.radius * p.radius; // Sum of areas of individual circles

                // Generate points on the circumference of each particle
                for (let i = 0; i < pointsPerCircle; i++) {
                    const angle = (i / pointsPerCircle) * Math.PI * 2;
                    outerPoints.push({
                        x: p.x + p.radius * Math.cos(angle),
                        y: p.y + p.radius * Math.sin(angle)
                    });
                }
            }

            // Calculate convex hull perimeter from all outer points
            const hullPoints = convexHull(outerPoints);
            let clusterPerimeter = 0;

            if (hullPoints.length < 2) {
                return { circularity: 0, totalArea: totalArea, clusterPerimeter: 0 }; // Degenerate case (e.g., all sampled points are identical)
            } else if (hullPoints.length === 2) {
                // If the hull is just two points, it's a line segment. The "perimeter" of this degenerate shape
                // for circularity purposes can be approximated as twice the distance between them.
                clusterPerimeter = distance(hullPoints[0], hullPoints[1]) * 2;
            } else {
                // Calculate perimeter of the polygon formed by the convex hull
                for (let i = 0; i < hullPoints.length; i++) {
                    const p1 = hullPoints[i];
                    const p2 = hullPoints[(i + 1) % hullPoints.length]; // Wrap around to the first point
                    clusterPerimeter += distance(p1, p2);
                }
            }

            if (clusterPerimeter === 0) {
                return { circularity: 0, totalArea: totalArea, clusterPerimeter: 0 }; // Avoid division by zero if perimeter is zero (e.g., all points are identical)
            }

            // Calculate the area of a circle with the same perimeter as the cluster's convex hull.
            // Perimeter of a circle = 2 * PI * r_equivalent
            // r_equivalent = Perimeter / (2 * PI)
            // Area of equivalent circle = PI * r_equivalent^2 = PI * Perimeter^2 / (4 * PI)
            const areaOfEquivalentCircle = (clusterPerimeter * clusterPerimeter) / (4 * Math.PI);

            // Circularity is the ratio of the cluster's actual area to the area of a circle with the same perimeter.
            // This is equivalent to (4 * PI * totalArea) / (clusterPerimeter * clusterPerimeter)
            const circularity = totalArea / areaOfEquivalentCircle;
            
            return { circularity: Math.min(1.0, Math.max(0.0, circularity)), totalArea: totalArea, clusterPerimeter: clusterPerimeter }; // Clamp between 0 and 1
        }


        function updateStatsDisplay(objectX, objectY, speed, rotation, mass, vx, vy, circularity, area, perimeter, objectName) {
            const circularityPercentage = (circularity * 100).toFixed(2);
            let statsHeading = "";

            if (objectName === "S1") {
                statsHeading = "STAR STATS:";
            } else if (objectName.startsWith("P")) {
                statsHeading = "PARTICLE STATS:";
            } else if (objectName.startsWith("C")) {
                statsHeading = "CLUSTER STATS:";
            } else {
                statsHeading = "OBJECT STATS:";
            }

            const statsContent = `
                <div>
                    <span style="font-weight: bold;">${statsHeading}</span><br>
                    Name: ${objectName}<br>
                    Pos: (${objectX.toFixed(0)}, ${objectY.toFixed(0)})<br>
                    Vx: ${vx.toFixed(2)} Vy: ${vy.toFixed(2)}<br>
                    Speed: ${speed.toFixed(2)}<br>
                    Mass: ${mass.toFixed(2)}U<br>
                    Rotation Speed: ${rotation.toFixed(2)}°/frame<br>
                    Area: ${area.toFixed(2)} Pixels<br>
                    Perimeter: ${perimeter.toFixed(2)} Pixels<br>
                    Circularity: ${circularityPercentage}%
                </div>
            `;
            statsDisplay.innerHTML = statsContent;
        }

        function teleportToRandomParticle() {
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            // Filter for true single particles (not part of any cluster)
            const singleParticles = nonStarParticles.filter(p => findCluster(p).length === 1);
            
            if (singleParticles.length > 0) {
                const randomIndex = Math.floor(Math.random() * singleParticles.length);
                trackedParticle = singleParticles[randomIndex];
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                cameraWorldX = trackedParticle.x;
                cameraWorldY = trackedParticle.y;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                if (nonStarParticles.length > 0) { // If no single particles, track any non-star particle
                    const randomIndex = Math.floor(Math.random() * nonStarParticles.length);
                    trackedParticle = nonStarParticles[randomIndex];
                    isTracking = true;
                    toggleTrackingBtn.textContent = 'Tracking ON';
                    statsDisplay.classList.remove('hidden');

                    cameraWorldX = trackedParticle.x;
                    cameraWorldY = trackedParticle.y;
                    trackingOffsetX = 0;
                    trackingOffsetY = 0;
                } else {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    statsDisplay.classList.add('hidden');
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                }
            }
        }

        function teleportToRandomCluster() {
            const { clusters } = countGlobalStats(); // Get actual clusters (size > 1)
            if (clusters.length > 0) {
                const randomIndex = Math.floor(Math.random() * clusters.length);
                const randomCluster = clusters[randomIndex];

                let sumX = 0;
                let sumY = 0;
                let totalMass = 0;
                for (const p of randomCluster) {
                    sumX += p.x * p.mass;
                    sumY += p.y * p.mass;
                    totalMass += p.mass;
                }
                const clusterCenterX = sumX / totalMass;
                const clusterCenterY = sumY / totalMass;

                trackedParticle = randomCluster[0]; // Track a particle within the cluster to ensure it's "alive"
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                cameraWorldX = clusterCenterX;
                cameraWorldY = clusterCenterY;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                statsDisplay.classList.add('hidden');
                cameraWorldX = 0;
                cameraWorldY = 0;
            }
        }

        function teleportToRandomObject() {
            const star = particles.find(p => p.isStar);
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            const { clusters } = countGlobalStats();

            const trackableObjects = [];
            if (star && star.isAlive) {
                trackableObjects.push(star);
            }
            // Add single particles
            nonStarParticles.forEach(p => {
                if (findCluster(p).length === 1) { // Only add if it's a true single particle
                    trackableObjects.push(p);
                }
            });
            // Add representative particle for each cluster
            clusters.forEach(cluster => {
                if (cluster.length > 0) {
                    trackableObjects.push(cluster[0]); // Use first particle of cluster as representative
                }
            });

            if (trackableObjects.length > 0) {
                const randomIndex = Math.floor(Math.random() * trackableObjects.length);
                trackedParticle = trackableObjects[randomIndex];
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                let targetX = trackedParticle.x;
                let targetY = trackedParticle.y;

                // If the tracked object is part of a cluster (and not the star itself), track its center of mass
                if (!trackedParticle.isStar && findCluster(trackedParticle).length > 1) {
                    const cluster = findCluster(trackedParticle);
                    let sumX = 0;
                    let sumY = 0;
                    let totalMass = 0;
                    for (const p of cluster) {
                        sumX += p.x * p.mass;
                        sumY += p.y * p.mass;
                        totalMass += p.mass;
                    }
                    targetX = sumX / totalMass;
                    targetY = sumY / totalMass;
                }

                cameraWorldX = targetX;
                cameraWorldY = targetY;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                statsDisplay.classList.add('hidden');
                cameraWorldX = 0;
                cameraWorldY = 0;
            }
        }


        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { totalParticles, totalClusters } = countGlobalStats();
            totalParticlesDisplay.textContent = totalParticles;
            totalClustersDisplay.textContent = totalClusters;

            if (isTracking && trackedParticle) {
                if (!trackedParticle.isAlive) {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    statsDisplay.classList.add('hidden');
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                    return; // Exit early if tracking is stopped
                }

                const currentCluster = findCluster(trackedParticle);

                // If the tracked particle is a single particle and it gets absorbed, findCluster will return empty
                if (currentCluster.length === 0 && !trackedParticle.isStar) {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    statsDisplay.classList.add('hidden');
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                    return; // Exit early if tracking is stopped
                }

                // If tracking a star, currentCluster will be empty, so handle star specifically
                let displayObjectName = "";
                let displayObjectX = 0;
                let displayObjectY = 0;
                let displayObjectVx = 0;
                let displayObjectVy = 0;
                let displayObjectSpeed = 0;
                let displayObjectRotation = 0;
                let displayObjectMass = 0;
                let displayObjectCircularity = 1.0;
                let displayObjectArea = 0;
                let displayObjectPerimeter = 0;

                if (trackedParticle.isStar) {
                    displayObjectName = trackedParticle.name;
                    displayObjectX = trackedParticle.x;
                    displayObjectY = trackedParticle.y;
                    displayObjectMass = trackedParticle.mass;
                    displayObjectVx = trackedParticle.vx;
                    displayObjectVy = trackedParticle.vy;
                    displayObjectSpeed = Math.sqrt(displayObjectVx * displayObjectVx + displayObjectVy * displayObjectVy);
                    displayObjectRotation = 0; // Star doesn't rotate for stats
                    const starArea = Math.PI * trackedParticle.radius * trackedParticle.radius;
                    const starPerimeter = 2 * Math.PI * trackedParticle.radius;
                    displayObjectCircularity = 1.0; // Star is a perfect circle
                    displayObjectArea = starArea;
                    displayObjectPerimeter = starPerimeter;
                } else {
                    // For particles or clusters, calculate stats based on the identified cluster
                    displayObjectName = getClusterName(currentCluster);

                    let sumXForStats = 0;
                    let sumYForStats = 0;
                    let sumVxForStats = 0;
                    let sumVyForStats = 0;
                    displayObjectMass = 0;
                    for (const p of currentCluster) {
                        sumXForStats += p.x * p.mass;
                        sumYForStats += p.y * p.mass;
                        sumVxForStats += p.vx * p.mass;
                        sumVyForStats += p.vy * p.mass;
                        displayObjectMass += p.mass;
                    }

                    displayObjectX = sumXForStats / displayObjectMass;
                    displayObjectY = sumYForStats / displayObjectMass;
                    displayObjectVx = sumVxForStats / displayObjectMass;
                    displayObjectVy = sumVyForStats / displayObjectMass;

                    let totalAngularMomentum = 0;
                    let effectiveMomentOfInertia = 0;
                    for (const p of currentCluster) {
                        const r_x = p.x - displayObjectX;
                        const r_y = p.y - displayObjectY;
                        const v_rel_x = p.vx - displayObjectVx;
                        const v_rel_y = p.vy - displayObjectVy;

                        totalAngularMomentum += p.mass * (r_x * v_rel_y - r_y * v_rel_x);
                        effectiveMomentOfInertia += p.mass * (r_x * r_x + r_y * r_y);
                    }

                    displayObjectSpeed = Math.sqrt(displayObjectVx * displayObjectVx + displayObjectVy * displayObjectVy);
                    if (effectiveMomentOfInertia > 0) {
                        const angularSpeedRad = totalAngularMomentum / effectiveMomentOfInertia;
                        displayObjectRotation = angularSpeedRad * (180 / Math.PI);
                    }

                    const circularityResult = calculateCircularity(currentCluster);
                    displayObjectCircularity = circularityResult.circularity;
                    displayObjectArea = circularityResult.totalArea;
                    displayObjectPerimeter = circularityResult.clusterPerimeter;
                }

                updateStatsDisplay(
                    displayObjectX,
                    displayObjectY,
                    displayObjectSpeed,
                    displayObjectRotation,
                    displayObjectMass,
                    displayObjectVx,
                    displayObjectVy,
                    displayObjectCircularity,
                    displayObjectArea,
                    displayObjectPerimeter,
                    displayObjectName
                );

                statsDisplay.classList.remove('hidden');

                if (!isPaused) {
                    if (keys['w']) trackingOffsetY += CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['s']) trackingOffsetY -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['a']) trackingOffsetX -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['d']) trackingOffsetX += CAMERA_MOVE_SPEED / zoomLevel;

                    if (!keys['w'] && !keys['s']) trackingOffsetY *= 0.9;
                    if (!keys['a'] && !keys['d']) trackingOffsetX *= 0.9;

                    cameraWorldX = displayObjectX + trackingOffsetX;
                    cameraWorldY = displayObjectY + trackingOffsetY;
                }
            } else {
                statsDisplay.classList.add('hidden');

                if (!isPaused) {
                    if (keys['w']) cameraWorldY += CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['s']) cameraWorldY -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['a']) cameraWorldX -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['d']) cameraWorldX += CAMERA_MOVE_SPEED / zoomLevel;
                }
            }

            if (!isPaused) {
                applyGravity();
                handleCollisions();

                particles.forEach(p => {
                    p.update();
                });

                simulationTime++;
                simTimeDisplay.textContent = simulationTime;
            }

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-cameraWorldX, -cameraWorldY);

            particles.forEach(p => p.draw());

            // Draw tracking indicator if tracking is on and a particle is tracked
            if (isTracking && trackedParticle) {
                const currentCluster = findCluster(trackedParticle);
                
                // If the tracked particle is the star, draw around it.
                // If it was a regular particle and it got absorbed (no longer in findCluster), stop tracking handled above.
                // If it's a particle that's now part of a cluster or a cluster itself, use cluster center.
                let targetBoundingX, targetBoundingY;

                if (trackedParticle.isStar) {
                    targetBoundingX = trackedParticle.x;
                    targetBoundingY = trackedParticle.y;
                } else if (currentCluster.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    let totalMass = 0;
                    for (const p of currentCluster) {
                        sumX += p.x * p.mass;
                        sumY += p.y * p.mass;
                        totalMass += p.mass;
                    }
                    targetBoundingX = sumX / totalMass;
                    targetBoundingY = sumY / totalMass;
                } else {
                    // This case should ideally be caught by the earlier check where isTracking is set to false.
                    // But as a fallback, if currentCluster is empty, don't draw.
                    targetBoundingX = trackedParticle.x;
                    targetBoundingY = trackedParticle.y;
                }

                // If tracking a star, use its radius. Otherwise, calculate bounding box of cluster.
                let trackingCircleRadius;
                if (trackedParticle.isStar) {
                    trackingCircleRadius = trackedParticle.radius + 5; // Slightly larger than star
                } else if (currentCluster.length > 0) {
                    let clusterMinX = Infinity;
                    let clusterMaxX = -Infinity;
                    let clusterMinY = Infinity;
                    let clusterMaxY = -Infinity;

                    for (const p of currentCluster) {
                        clusterMinX = Math.min(clusterMinX, p.x - p.radius);
                        clusterMaxX = Math.max(clusterMaxX, p.x + p.radius);
                        clusterMinY = Math.min(clusterMinY, p.y - p.radius);
                        clusterMaxY = Math.max(clusterMaxY, p.y + p.radius);
                    }
                    const boundingBoxWidth = clusterMaxX - clusterMinX;
                    const boundingBoxHeight = clusterMaxY - clusterMinY;
                    trackingCircleRadius = Math.sqrt(boundingBoxWidth * boundingBoxWidth + boundingBoxHeight * boundingBoxHeight) / 2 + 5;
                } else {
                    // No valid cluster found, effectively stop drawing tracking indicator
                    trackingCircleRadius = 0;
                }

                if (trackingCircleRadius > 0) {
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(targetBoundingX, targetBoundingY, trackingCircleRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Draw Roche Limit if enabled
            if (showRocheLimit) {
                const star = particles.find(p => p.isStar); // Get the star object
                if (star) {
                    // Calculate star's density
                    const starVolume = (4/3) * Math.PI * Math.pow(star.radius, 3);
                    const starDensity = star.mass / starVolume;

                    // Use PARTICLE_DENSITY as the density of the secondary body (cluster/particle)
                    const secondaryDensity = PARTICLE_DENSITY;

                    // Classical Roche Limit for a fluid body
                    // R_roche = R_primary * 2.44 * (rho_primary / rho_secondary)^(1/3)
                    let rocheLimitRadius = 0;
                    if (secondaryDensity > 0) { // Prevent division by zero
                        rocheLimitRadius = STAR_RADIUS * 2.44 * Math.pow(starDensity / secondaryDensity, 1/3);
                    } else {
                        rocheLimitRadius = 0; // If secondary density is zero, Roche limit is undefined or infinite
                    }
                    
                    // Add the star's radius to the calculated limit, as the formula gives distance from center
                    // Subtract C/2.44 pixels as requested
                    rocheLimitRadius = rocheLimitRadius + star.radius - (COHESION_FORCE_G / 2.44);

                    // Only draw if the radius is positive and outside the star's radius
                    if (rocheLimitRadius > star.radius && rocheLimitRadius > 0) {
                        ctx.strokeStyle = '#FFD700'; // Gold color for the Roche limit
                        ctx.lineWidth = 1.5; // Slightly thicker line
                        ctx.setLineDash([8, 8]); // Dashed line
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, rocheLimitRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]); // Reset line dash
                    }
                }
            }

            ctx.restore();
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // Home button functionality
        homeButton.addEventListener('click', (event) => {
            // Prevent the default link behavior
            event.preventDefault();
            // Navigate to the homepage in the same tab
            window.location.href = homeButton.href;
        });

        resetSimBtn.addEventListener('click', initSimulation);
        resetViewBtn.addEventListener('click', resetView);

        pausePlayBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pausePlayBtn.textContent = isPaused ? 'Play' : 'Pause';
        });

        teleportParticleBtn.addEventListener('click', teleportToRandomParticle);
        teleportClusterBtn.addEventListener('click', teleportToRandomCluster);
        teleportRandomObjectBtn.addEventListener('click', teleportToRandomObject);

        toggleSettingsBtn.addEventListener('click', () => {
            modifierGroup.classList.toggle('hidden');
            if (modifierGroup.classList.contains('hidden')) {
                toggleSettingsBtn.textContent = 'Show Settings';
            } else {
                toggleSettingsBtn.textContent = 'Hide Settings';
            }
        });

        toggleScrollLockBtn.addEventListener('click', () => {
            isScrollLocked = !isScrollLocked;
            if (isScrollLocked) {
                document.body.style.overflow = 'hidden';
                toggleScrollLockBtn.textContent = 'Unlock Scroll';
            } else {
                document.body.style.overflow = 'auto';
                toggleScrollLockBtn.textContent = 'Lock Scroll';
            }
        });

        resetDefaultsBtn.addEventListener('click', () => {
            particleCountInput.value = DEFAULT_PARTICLE_COUNT;
            minParticleSizeInput.value = DEFAULT_MIN_PARTICLE_RADIUS;
            maxParticleSizeInput.value = DEFAULT_MAX_PARTICLE_RADIUS;
            minSpawnDistanceInput.value = DEFAULT_INITIAL_DISK_INNER_RADIUS;
            maxSpawnDistanceInput.value = DEFAULT_INITIAL_DISK_OUTER_RADIUS;
            starMassInput.value = DEFAULT_STAR_MASS;
            gravityConstantInput.value = DEFAULT_G;
            cohesionConstantInput.value = DEFAULT_COHESION_FORCE_G;
            velocityDampeningInput.value = DEFAULT_COLLISION_DAMPENING; // Ensure input reflects default
        });

        // Event listener for toggling Roche Limit visibility
        toggleRocheLimitBtn.addEventListener('click', () => {
            showRocheLimit = !showRocheLimit;
            toggleRocheLimitBtn.textContent = showRocheLimit ? 'Hide Roche Limit' : 'Show Roche Limit';
        });

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            const worldClickX = (clickX - canvas.width / 2) / zoomLevel + cameraWorldX;
            const worldClickY = (clickY - canvas.height / 2) / zoomLevel + cameraWorldY;

            let clickedParticle = null;
            for (const p of particles) {
                const distFromClickToParticleCenterSq = distanceSq({x: worldClickX, y: worldClickY}, p);
                if (distFromClickToParticleCenterSq <= p.radius * p.radius) {
                    clickedParticle = p;
                    break;
                }
            }

            if (clickedParticle) {
                if (isTracking && trackedParticle === clickedParticle) {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                    statsDisplay.classList.add('hidden');
                } else {
                    trackedParticle = clickedParticle;
                    isTracking = true;
                    toggleTrackingBtn.textContent = 'Tracking ON';
                    statsDisplay.classList.remove('hidden');

                    const initialCluster = findCluster(trackedParticle);
                    let initialClusterCenterX = clickedParticle.x;
                    let initialClusterCenterY = clickedParticle.y;

                    if (trackedParticle.isStar) {
                        initialClusterCenterX = trackedParticle.x;
                        initialClusterCenterY = trackedParticle.y;
                    } else if (initialCluster.length > 0) {
                        let sumX = 0;
                        let sumY = 0;
                        let totalMass = 0;
                        for (const p of initialCluster) {
                            sumX += p.x * p.mass;
                            sumY += p.y * p.mass;
                            totalMass += p.mass;
                        }
                        initialClusterCenterX = sumX / totalMass;
                        initialClusterCenterY = sumY / totalMass;
                    }
                    cameraWorldX = initialClusterCenterX;
                    cameraWorldY = initialClusterCenterY;
                }

                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                trackingOffsetX = 0;
                trackingOffsetY = 0;
                statsDisplay.classList.add('hidden');
            }
        });

        toggleTrackingBtn.addEventListener('click', () => {
            isTracking = !isTracking;
            toggleTrackingBtn.textContent = isTracking ? 'Tracking ON' : 'Toggle Tracking';
            if (!isTracking) {
                trackedParticle = null;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
                cameraWorldX = 0;
                cameraWorldY = 0;
                statsDisplay.classList.add('hidden');
            } else {
                // If tracking is turned ON but no particle is currently tracked, default to the star.
                if (!trackedParticle) {
                    trackedParticle = particles.find(p => p.isStar);
                    if (trackedParticle) {
                        cameraWorldX = trackedParticle.x;
                        cameraWorldY = trackedParticle.y;
                    }
                }
                statsDisplay.classList.remove('hidden');
            }
        });


        zoomOutBtn.addEventListener('click', () => {
            zoomLevel = Math.max(0.2, zoomLevel - 0.1);
            updateZoomLevelDisplay();
        });
        zoomInBtn.addEventListener('click', () => {
            zoomLevel = Math.min(20.0, zoomLevel + 0.1);
            updateZoomLevelDisplay();
        });
        zoomOutFastBtn.addEventListener('click', () => {
            zoomLevel = Math.max(0.2, zoomLevel - 1.0);
            updateZoomLevelDisplay();
        });
        zoomInFastBtn.addEventListener('click', () => {
            zoomLevel = Math.min(20.0, zoomLevel + 1.0);
            updateZoomLevelDisplay();
        });

        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomAmount = event.deltaY * -0.001;
            zoomLevel = Math.max(0.2, Math.min(20.0, zoomLevel + zoomAmount));
            updateZoomLevelDisplay();
        });

        canvas.addEventListener('mousedown', (event) => {
            if (event.touches && event.touches.length > 1) return;
            isDragging = true;
            lastMouseX = event.clientX || event.touches[0].clientX;
            lastMouseY = event.clientY || event.touches[0].clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging) {
                if (event.touches && event.touches.length > 1) {
                    isDragging = false;
                    return;
                }
                const currentX = event.clientX || event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const dx = currentX - lastMouseX;
                const dy = currentY - lastMouseY;

                cameraWorldX -= dx / zoomLevel;
                cameraWorldY -= dy / zoomLevel;

                lastMouseX = currentX;
                lastMouseY = currentY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        let initialPinchDistance = 0;
        let initialZoomLevel = 1.0;
        let lastCenter = { x: 0, y: 0 };

        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                isDragging = false;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoomLevel = zoomLevel;

                lastCenter.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                lastCenter.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;

            } else if (event.touches.length === 1) {
                isDragging = true;
                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            if (isDragging && event.touches.length === 1) {
                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const dx = currentX - lastMouseX;
                const dy = currentY - lastMouseY;

                cameraWorldX -= dx / zoomLevel;
                cameraWorldY -= dy / zoomLevel;

                lastMouseX = currentX;
                lastMouseY = currentY;
            } else if (event.touches.length === 2) {
                event.preventDefault();
                isDragging = false;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);

                if (initialPinchDistance > 0) {
                    const zoomFactor = currentPinchDistance / initialPinchDistance;
                    zoomLevel = Math.max(0.2, Math.min(20.0, initialZoomLevel * zoomFactor));
                    updateZoomLevelDisplay();
                }

                const currentCenterX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                const currentCenterY = (event.touches[0].clientY + event.touches[1].clientY) / 2;

                const panDx = currentCenterX - lastCenter.x;
                const panDy = currentCenterY - lastCenter.y;

                cameraWorldX -= panDx / zoomLevel;
                cameraWorldY -= panDy / zoomLevel;

                lastCenter.x = currentCenterX;
                lastCenter.y = currentCenterY;

            }
        }, { passive: false });

        canvas.addEventListener('touchend', (event) => {
            initialPinchDistance = 0;
            isDragging = false;
        });
        canvas.addEventListener('touchcancel', (event) => {
            initialPinchDistance = 0;
            isDragging = false;
        });


        window.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });


        window.onload = function() {
            resizeCanvas();

            // Load the new "bonk" sounds
            crashloudAudio = new Audio('bonkloud.mp3');
            crashquietAudio = new Audio('bonkquiet.mp3');

            minParticleSizeInput.value = MIN_PARTICLE_RADIUS;
            maxParticleSizeInput.value = MAX_PARTICLE_RADIUS;
            minSpawnDistanceInput.value = INITIAL_DISK_INNER_RADIUS;
            maxSpawnDistanceInput.value = INITIAL_DISK_OUTER_RADIUS;
            starMassInput.value = STAR_MASS;
            gravityConstantInput.value = G;
            cohesionConstantInput.value = COHESION_FORCE_G;
            velocityDampeningInput.value = DEFAULT_COLLISION_DAMPENING; // Ensure input reflects default

            // Set initial scroll state and button text
            document.body.style.overflow = isScrollLocked ? 'hidden' : 'auto';
            toggleScrollLockBtn.textContent = isScrollLocked ? 'Unlock Scroll' : 'Lock Scroll';

            initSimulation();
            animate();
        };

        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
